@namespace Cads
@using cads_gui.Data

@implements IAsyncDisposable


@inject IJSRuntime JS
@inject BeltService Beltservice

<plotly-container>
    <div id="container-profile" @ref="@jsPlotElement"></div>
</plotly-container>


@code {

  [Parameter]
	public Scan scan {get; set;} = new();
  
  [Parameter]
  public EventCallback<int> XIndex {get; set;}
  
  private DotNetObjectReference<TrendPlot>? selfReference;

  protected IJSObjectReference? jsPlot;
  protected ElementReference jsPlotElement;  

  protected (int,float[],string)? updatePlot;
  
  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      selfReference = DotNetObjectReference.Create(this);
      await using var module = await JS.InvokeAsync<IJSObjectReference>("import", "./plot.js");
      jsPlot = await module.InvokeAsync<IJSObjectReference>("mk_TrendPlot",jsPlotElement,scan.z_min + 12,scan.z_max,selfReference);
      
      if(updatePlot is not null) {

        var (index,z,color) = updatePlot.Value;
        await UpdatePlotAsync(index,z,color);
        updatePlot = null;
      }
    }
  }

  public async Task UpdatePlotAsync(int index, float[] z, string color) {
    
    if(jsPlot is not null && scan.HasData) 
    {  
      var (xMin,xRes) = scan.XBegin;
      var xAxisE = from x in Enumerable.Range(0,z.Count()) select (xMin + x * xRes) / 1000; 
      var xAxis = xAxisE.ToArray();
      await jsPlot.InvokeVoidAsync("updatePlot",index,xAxis, z, color);
    }else {
      updatePlot = (index,z,color);
    }
  }


  [JSInvokable]
  public async Task TrendPlotClicked(int xIndex)
  {
    await XIndex.InvokeAsync(xIndex);
  }

  async ValueTask IAsyncDisposable.DisposeAsync()
  {
    updatePlot = null;
    try {
      selfReference?.Dispose();
    if (jsPlot is not null) {
     await jsPlot.DisposeAsync();
     jsPlot = null;
    }
    }catch(Microsoft.JSInterop.JSDisconnectedException) {}
  }

}
