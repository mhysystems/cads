@page "/site/dashboard/{site}/{conveyor}"

@using Cads
@using Microsoft.Extensions.Logging
@using System.Collections.Concurrent
@using Fluxor.Blazor.Store

@inject IJSRuntime JS
@inject BeltService Beltservice
@inject ILogger<Main> logger
@inject ISnackbar Snackbar

@inherits Fluxor.Blazor.Web.Components.FluxorComponent

<SiteHeader ShowDraw site="@site" conveyor="@conveyor">
  <SearchControls SelectZDepthParams="@LoadZDepthParamsAsync" DateChanged="@DateChanged" Belt="@belt"
    JumpTo="@JumpToAsync" StepBack="@StepBackward" StepForward="@StepForward" Search="@SearchBelt" />
</SiteHeader>

<MudContainer MaxWidth="MaxWidth.False" Class="ma-0 pa-0"
  Style="width:calc(100vw - var(--mud-drawer-width-mini-left));height:calc(100vh - var(--mud-appbar-height)">
  <MudGrid Class="ma-0" Style="height:100%" Spacing=0>
    <MudItem xs="12" Class="d-flex" Style="height:40%">

      <MudTooltip Placement="Placement.End" Text="The circle represents the entire belt. Damage locations that match the search criteria are indicated in white. Clicking on the circle triggers the plot to jump to that location. If too many damage locations are found they are limited">
      <DoughnutPlot @ref="doughnutPlot" Style="display:contents" Belt="@belt" Y="@UpdateYAsync" />
        </MudTooltip> 
      <MudContainer Class="d-flex flex-column ">
        <ZDepthQuery @ref="zDepthQuery" Belt=@Beltservice.GetBelt(site,conveyor)></ZDepthQuery>
        <MudExpansionPanels Class="z-30">
          <MudExpansionPanel Class="overflow-auto" Dense="true" MaxHeight="270" Text="Search Results">
            <Ztable @ref="@zDepthTabe" selectedRow="@UpdateYAsync"></Ztable>
          </MudExpansionPanel>

        </MudExpansionPanels>
      </MudContainer>

      <RealtimeDetection Site="@site" Conveyor="@conveyor" />

      <BeltMetadata Site="@site" Conveyor="@conveyor" />
    </MudItem>

    <MudItem xs="12" Style="height:50%">
      <MudProgressLinear Color="Color.Secondary" Class="my-0" Value="@progressPercentage" />
      <SurfacePlot @ref="surfacePlot" Belt="@belt" YIndex="@UpdateProfilePlotAsync"></SurfacePlot>
    </MudItem>
    <MudItem xs="12" Style="height:10%">
      <ProfilePlot @ref="profilePlot" Belt="@belt"></ProfilePlot>
    </MudItem>
  </MudGrid>
</MudContainer>

@code {

  [Parameter]
  public string site { get; set; }
  [Parameter]
  public string conveyor { get; set; }

  // Bindings
  private DotNetObjectReference<Main> selfReference;
  SurfacePlot surfacePlot;
  ProfilePlot profilePlot;
  ZDepthQuery zDepthQuery;
  DoughnutPlot doughnutPlot;

  Ztable zDepthTabe;

  double _currentY = 0;
  protected double currentY
  {
    get { return _currentY; }
    set
    {
      _currentY = value;
      var action = new YAction(value);
      Dispatcher.Dispatch(action);
    }
  }
  double progressPercentage = 0;

  protected Belt belt { get; set; }
  protected IJSObjectReference plotDataCache;
  protected IJSObjectReference plotData;
  [Inject]
  public IDispatcher Dispatcher { get; set; }

  protected override async Task OnInitializedAsync()
  {
    belt = Beltservice.GetBelt(site, conveyor);
    var action = new BeltAction(belt);
    Dispatcher.Dispatch(action);
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      selfReference = DotNetObjectReference.Create(this);
      var module = await JS.InvokeAsync<IJSObjectReference>("import", "./plot.js");
      plotDataCache = await module.InvokeAsync<IJSObjectReference>("mk_PlotDataCache", selfReference);
      await UpdateYAsync(currentY);
    }
  }

  async Task LoadZDepthParamsAsync(IEnumerable<SavedZDepthParams> xs)
  {
    await zDepthQuery.LoadZDepthParamsAsync(xs);
  }

  async Task UpdateProfilePlotAsync(ValueTuple<int, double> args)
  {
    var (yIndex, y) = args;
    Dispatcher.Dispatch(new YAction(y));
    var plotDataPromise = await plotDataCache.InvokeAsync<IJSObjectReference>("getLastFetch");
    await profilePlot.UpdatePlotAsync(plotDataPromise, yIndex);
  }

  async Task StepForward()
  {
    currentY += (belt.y_res * 1024);
    currentY = NoAsp.Mod(currentY, belt.Ymax);
    await UpdateYAsync(currentY);
  }

  async Task StepBackward()
  {
    currentY -= (belt.y_res * 1024);
    currentY = NoAsp.Mod(currentY, belt.Ymax);
    await UpdateYAsync(currentY);
  }

  [JSInvokable]
  public async Task SetProgressPercentageAsync(double p)
  {
    if (p < 0)
    {
      p = 0;
    }

    if (p > 1)
    {
      p = 1;
    }

    progressPercentage = 100 * p;
    StateHasChanged();

  }

  async Task UpdateYAsync(ZDepth zd)
  {
    currentY = zd.y;
    surfacePlot.Loading = true;
    try
    {
      var plotDataPromise = await plotDataCache.InvokeAsync<IJSObjectReference>("fetchData", belt.name, currentY, 512, 512);

      await surfacePlot.UpdatePlotWithOverlayAsync(plotDataPromise, zd);
      await profilePlot.UpdatePlotAsync(plotDataPromise);
    }
    catch (Exception)
    {
      Snackbar.Add($"Problem retrieving data", Severity.Error);
    }
    surfacePlot.Loading = false;
  }

  async Task UpdateYAsync(double y)
  {
    currentY = y;
    surfacePlot.Loading = true;
    try
    {
      var plotDataPromise = await plotDataCache.InvokeAsync<IJSObjectReference>("fetchData", belt.name, currentY, 512, 512);

      await surfacePlot.UpdatePlotAsync(plotDataPromise);
      await profilePlot.UpdatePlotAsync(plotDataPromise);
    }
    catch (Exception)
    {
      Snackbar.Add($"Problem retrieving data", Severity.Error);
    }
    surfacePlot.Loading = false;
  }

  async Task JumpToAsync(double y)
  {
    await UpdateYAsync(1000 * y);
  }

  async Task DateChanged(DateTime? date)
  {

    if (!date.HasValue)
    {
      return;
    }


    var b = Beltservice.GetBelt(site, conveyor, date.Value);

    if (b is not null)
    {
      Snackbar.Add($"Loading belt scan on {DateOnly.FromDateTime(date.Value)}", Severity.Info);
      belt = b;
      await UpdateYAsync(currentY);
      StateHasChanged();
    }
    else
    {
      Snackbar.Add($"No belt scan for {DateOnly.FromDateTime(date.Value)}", Severity.Warning);
    }
  }


  async Task SearchBelt1()
  {

    var scan = zDepthQuery.SearchParameters;
    doughnutPlot.AnimateSearch = true;

    await Task.Delay(1);

    //z_depth_value.Clear();

    var procn = Environment.ProcessorCount;

    long y_len = 1 + ((long)belt.YmaxN / procn);
    var offsets = from number in Enumerable.Range(0, procn) select (number * y_len + 1, y_len);

    P3 zmin = new P3(0, 0, Double.MaxValue);

    var zDepth = new ConcurrentBag<List<ZDepth>>();
    //foreach(var offset in offsets)
    //Parallel.ForEach(offsets, async (offset) =>
    //var ts = offsets.Select(async (offset) =>
    try
    {
      await Parallel.ForEachAsync(offsets, async (offset, token) =>
      {
        logger.LogDebug("Parallel.ForEach Thread ID: " + System.Threading.Thread.CurrentThread.ManagedThreadId);

        await foreach (var z in Beltservice.BeltScanAsync(scan.Width, scan.Length, scan.Percentage, scan.Depth, belt,
  offset.Item1, offset.Item2))
        {
          var (xs, pz) = z;
          zmin = zmin.z < pz.z ? zmin : pz;
          zDepth.Add(xs);
          // z_depth_value.AddRange(xs);
        }
      });
    }
    catch (Exception e)
    {
      logger.LogError(e.Message);
    }


    if (zDepth.Any())
    {
      doughnutPlot.data = zDepth.SelectMany(i => i).OrderBy(i => i.y).Select(d => new
      PlotInfo(d.y, belt.FrameLength, d.z.z, "")).Take(1024).ToList();
      zDepthTabe.data = zDepth.SelectMany(i => i).Take(1024).ToList();
      var fn = zDepthQuery.MakeAreaOfInterest();
      surfacePlot.HighlightSurface(fn);

    }

    doughnutPlot.AnimateSearch = false;

  }

  async Task SearchBelt()
  {

    doughnutPlot.AnimateSearch = true;

    var limit = 64L;

    try
    {
      var zDepth = await Beltservice.BeltScanAsync2(zDepthQuery.SearchParameters, belt, limit);
      
      if(zDepth.Count > limit) {
        Snackbar.Add($"Too many results. Limited to {limit}", Severity.Warning);
      }

      doughnutPlot.data = zDepth.OrderBy(i => i.y).Take((int)limit).Select(d => new
      PlotInfo(d.y, belt.FrameLength, d.z.z, "")).ToList();
      
      zDepthTabe.data = zDepth;
      var fn = zDepthQuery.MakeAreaOfInterest();
      surfacePlot.HighlightSurface(fn);

    }
    catch (Exception e)
    {
      logger.LogError(e.Message);
    }

    doughnutPlot.AnimateSearch = false;

  } 

  public void Dispose() => selfReference?.Dispose();
}